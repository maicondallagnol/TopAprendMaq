\chapter{Desenvolvimento}\label{cap_desenv}

Para o desenvolvimento das atividades inicialmente foram escolhidos duas bases bases de dados. A primeira base a ser utilizada corresponde a dados de \textit{reviews} de um E-Commerce de Roupas Femininas contendo informações como idade, avaliação, categoria que o produto pertence, entre outras; A segunda base é composta dados educacionais que é coletado do sistema de gerenciamento de aprendizado, nela há dados como genero, nacionalidade, número de vezes que o aluno levanta a mão, entre outros dados.

\section{Pré-processamento e Visualização}
Ambas bases haviam dados categóricos e numéricos, na primeira base alguns atributos numéricos foram removidos e outros foram discretizados, ainda na primeira base também foram removidas transações que continham item (atributos=valor) faltantes; Para a segunda base visualizou através de um \textit{boxplot} que os dados numéricos estavam variando de 0 a 100 com uma média diferente para cada atributo, desta forma todos os dados numéricos foram discretizados em categorias binárias (abaixo ou acima média do atributo).

Para a aplicação dos algoritmos também transformou-se os dados do formato dataframe para um array da biblioteca Numpy.

\section{Regras de Associação}

Para aplicação do algoritmo Apriori inicialmente transformou-se os dados para um formato transacional utilizando TransactionEncoder, dessa forma utilizou-se o algoritmo apriori implementado na biblioteca mlxtend para extração dos \textit{itemsets} frequentes e $association_rules$ para extração das regras com confiança acima do corte.

Para aplicação Fp-Growth primeiramente implementou-se duas funções cujo propósito era: a. verificação de suporte e b. aplicação, cálculos das medidas. Nesta etapa algumas dificuldades foram encontradas uma vez que a implementação do algoritmo $fp_growth$ baixada pelo indexador de pacotes de python PyPI não retornava todas as medidas, portanta algumas tiveram que ser calculadas o que gerou alguns problemas ao se buscar os suportes do antecedente e consequente.

\section{Avaliação}
Devido aos problemas encontrados na etapa de extração das regras a avaliação dos resultados também foi comprometida, contudo ainda sim avaliou-se os resultados obtidos .

Para a primeira base o em ambos algoritmos utilizou-se suporte mínimo de 20\% e confiança de 80\% com o intuito de pegar mais regras mas que tivessem uma melhor confiança. Das regras geradas algumas se destacam como quando um adulto avalia como muito bom, com uma altíssima confiança ele vai recomendar a loja. Outra regra que se destaca pela conviction infinita é Knits $\rightarrow$ Tops, contudo esta poderia ser uma regra redundante dentro do escopo da base uma vez que o antecedente trata-se do nome de uma classe de produto enquanto o consequente de um departamento, de forma que é possível ter uma classe de produto pertencente apenas a um departamento, não agregando conhecimento algum apesar das altas estatísticas.

Para a segunda em ambos algoritmos utilizou-se suporte mínimo de 35\% e confiança de 80\%. Nesta base algumas regras redundantes também foram geradas como o local do nascimento levando para a nacionalidade e vice-versa. Outras regras já são mais interessantes como (Under-7, $overmeanraisedhands$) $\rightarrow$ $overmeanVisITedResources$ com uma alta confiança, isso leva ao ponto que as crianças que faltam menos e levantam a mão mais vezes que a média também são as crianças que visitam os recursos mais vezes que a média. Outra regra interessante seria Yes $\rightarrow$ Good, mostrando que pais que responderam a pesquisa para a escola tem um nível de satisfação bom com ela. Nestas duas regras exemplificadas os valores de \textit{leverage} ficaram em torno de 0.13, uma vez que está mais próximo de 0 do que de 1, pode-se concluir que essas regras estão indicando uma possível independência entre elas, contrastando com os valores de confiança obtidos.

Em teoria ambos algoritmos deveriam apresentar as mesmas regras para os mesmos valores de suporte e confiança mínima, contudo, devido algum possível problema na implementação, o algoritmo Apriori obteve mais regras que o FP-Growth na primeira base e menos na segunda base. Entretanto, para as regras que apareceram em ambos algoritmos todas as medições são iguais.

Para ambas bases os parametros foram alterados manualmente buscando um equilibrio entre um número não tão alto de regras e um bom valor de confiança a fim que pudessem ser facilmente visualizável. Para uma análise mais aprofundada, por exemplo, para segunda base, devido a presença de uma classe, poderia-se diminuir os valores de suporte e confiança buscando encontrar regras que tivessem como consequente os valores de classe de modo a gerar regras que pudessem ser usadas para classificar novas transações.